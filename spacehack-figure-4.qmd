---
title: "Code for Figure 4"
format: 
    html:
      toc: true
      self-contained: true
      highlight-style: github
      code-line-numbers: true
      code-fold: true
editor: source
editor_options: 
  chunk_output_type: console
#params:
#  datadir: 'test'
#  nmethod_range:
#    - 5
#    - 8
#  ground_truth:
#    - x
#    - y
#  nns: 6
#  name: "noname"
#  nclust_range:
#    - 10
#    - 12
#  nsmoothest: 30
#  obs_filter: NULL
---

## Retrieve parameters

```{r display-params}
datadir <- "data/libd-for-figure4"
name <- "fig4"

# gt <- c("parcellation_structure","parcellation_substructure")
# k <- 6
# nclust_range <- c(16,20,24)
# nmethod_range <- c(3,4,5,6,7,8,9)
# nsmoothest <- c(30)
# obs_filter <- 'parcellation_division=="TH" | parcellation_structure=="ZI"'

# if datadir ends in `/`, it screws up the parsing of method names,
# so add a check for it
stopifnot(tail(strsplit(datadir,"")[[1]],1)!="/")

```

## Packages / functions

```{r load-packages}
suppressPackageStartupMessages({
  library(SpatialExperiment)
  library(dplyr)
  library(ggplot2)
  library(cowplot)
  library(clue)
  library(khroma)
  library(scran)
  library(limma)
  library(tibble)
  library(readr)
  library(ggrepel)
  library(mclust)
  library(pheatmap)
  library(fastDummies)
  library(randomcoloR)
  library(STexampleData)
  library(reshape2)
  library(ClusteringMetrics)
  library(gridExtra)
})
source("utils.R")
```


## Load data

```{r load-data}

spe <- Visium_humanDLPFC()


# QUALITY CONTROL (QC)
# subset to keep only spots over tissue
spe <- spe[, colData(spe)$in_tissue == 1]
# identify mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
# calculate per-spot QC metrics
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
# select QC thresholds
qc_lib_size <- colData(spe)$sum < 600
qc_detected <- colData(spe)$detected < 400
qc_mito <- colData(spe)$subsets_mito_percent > 28
qc_cell_count <- colData(spe)$cell_count > 10
# combined set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito | qc_cell_count
colData(spe)$discard <- discard
# filter low-quality spots
spe <- spe[, !colData(spe)$discard]

# NORMALIZATION
# calculate logcounts using library size factors
spe <- logNormCounts(spe)
spe <- spe[!is_mito, ]

keep <- !is.na(spe$ground_truth)
spe <- spe[,keep]

spe$col <- spatialCoords(spe)[,"pxl_row_in_fullres"]
spe$row <- spatialCoords(spe)[,"pxl_col_in_fullres"]





cd <- colData(spe)

ggplot(cd %>% as.data.frame,
       aes(x = row, y = col, colour=ground_truth)) +
  geom_point() +
  scale_y_reverse()




base_clusterings <- read_tsv(file.path(datadir, 
                                       "combined_methods.tsv"),
                             show_col_types = FALSE)
colnames(base_clusterings)[1] <- "barcode_id"

mean(cd$barcode_id %in% base_clusterings$barcode_id)

mean(base_clusterings$barcode_id %in% cd$barcode_id)

dim(cd)

dim(base_clusterings)

m <- match(cd$barcode_id, base_clusterings$barcode_id)
sum(is.na(m))

base_clusterings <- base_clusterings[m,]

dim(base_clusterings)

cns <- grep("_label$", colnames(base_clusterings), 
            value = TRUE)
ss <- strsplit(cns, "_")
sapply(ss, length) %>% table
keep <- sapply(ss, function(u) u[length(u)-1]) %in% c(5,7,9)
base_clusterings <- base_clusterings[,c("barcode_id",cns[keep])]

dim(base_clusterings)

colnames(base_clusterings) <- gsub("_label","", colnames(base_clusterings))

# 
# base_clusts <- base_clusterings %>% 
#   inner_join(cd %>% as.data.frame %>% 
#                select(barcode_id, row, col, ground_truth))
# 
# 
# # quick scan
# lapply(base_clusts, head, 2)

all(base_clusterings$barcode_id == spe$barcode_id)


```


## Smoothness-entropy of base clusterings

```{r smoothness-entropy, fig.width=8, fig.height=6, eval=TRUE}

rownames(base_clusterings) <- NULL
base_clusterings <- base_clusterings %>%
  as.data.frame %>%
  column_to_rownames("barcode_id")

# find number of actual clusters per column
real_n <- apply(base_clusterings, 2, 
                function(u) length(unique(u)))
table(real_n)

base_clusterings <- base_clusterings[,real_n %in% c(5,7,9)]

real_n <- apply(base_clusterings, 2, 
                function(u) length(unique(u)))

nclust_range <- c(5,7,9)

# focus on clusterings at single number of clusters, loop through
p <- vector("list", length = length(nclust_range))
count <- 1

all_mses <- NULL
k <- 6

for(nclust in nclust_range) {

  these_clusterings <- base_clusterings %>%
    dplyr::select(names(which(real_n==nclust)))

  coords <- colData(spe) %>% as.data.frame %>%
    dplyr::select(barcode_id, row, col)

  df <- these_clusterings %>%
    rownames_to_column("barcode_id") %>%
    left_join(coords, by = "barcode_id")

  palette <- distinctColorPalette(nclust)
  names(palette) <- 1:nclust

  mse <- apply(these_clusterings, 2,
               function(u) spot_entropy(coords[,c("row","col")],
                                        u, k=k))
  cm <- mse %>% colMeans
  lv <- cm %>% sort %>% names
  print(cm)

  all_mses <- append(all_mses, cm)

  mse_m <- melt(mse, value.name = "entropy")
  mse_m$Var2 <- factor(mse_m$Var2, levels=lv)

  mse_p <- ggplot(mse_m, aes(Var2, entropy)) +
    geom_violin() +
    ylab(paste0("pointwise entropy (k=", k, ")")) +
    xlab("base clustering") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45,
                                     vjust = 1, hjust=1)) +
    geom_label(data = data.frame(Var2=names(cm),
                                 entropy = cm, label=round(cm,4)),
               mapping = aes(x=Var2,y=entropy,label=label), size = 2.5) +
    scale_y_sqrt() +
    ggtitle(paste0("Smoothness-entropy (", nclust, " clusters)"))

  # show(mse_p)
  p[[count]] <- mse_p
  count <- count+1

}


mse_anno <- spot_entropy(coords[,c("row","col")], spe$ground_truth, k=k) %>% 
  mean %>% setNames("annotation")
all_mses <- append(all_mses, mse_anno)

real_n <- c(real_n, length(unique(cd$ground_truth)))
names(real_n)[length(real_n)] <- "annotation"

all(names(all_mses) %in% colnames(aris_all))
all(colnames(aris_all) %in% names(all_mses))

ggsave(filename = paste0("smoothness-entropy.pdf"),
       plot = marrangeGrob(p, nrow=1, ncol=1),
       width = 8, height = 6)

all_mses

```


## Similarity of all clusterings

```{r clustering-similarities, fig.height=9, fig.width=10}
# keepers <- names(bases)
aris_all <- calc_aris(cbind(base_clusterings,
                            annotation=cd[,"ground_truth"]))


anno_row <- data.frame(entropy = all_mses)
rownames(anno_row) <- names(all_mses)

anno_row$n_clust <- real_n[rownames(anno_row)]

ph_all <- pheatmap(aris_all, fontsize = 5, annotation_row = anno_row)

clust <- cutree(ph_all$tree_row, k=2)
calc_summary(ph_all$tree_row, aris_all, 2, "annotation")

anno_row$clust <- clust[rownames(anno_row)]

show_these <- anno_row %>% filter(real_n==7, clust==2) %>% arrange(entropy) %>%
  rownames_to_column("method") %>%
  filter(method != "annotation") %>% head(8)


show(ph_all)
save_pheatmap_pdf(ph_all, "figure-4-heatmap-all.pdf", width = 9, height=8)


these_clusterings <- base_clusterings %>%
      dplyr::select(show_these$method) %>%
      align_classes("SEDR_dlpfc_7")
    

df <- cbind(these_clusterings, coords)

nclust <- 7
palette <- distinctColorPalette(nclust)
names(palette) <- 1:nclust

plots <- vector("list", 8)
count <- 0
  
for(meth in show_these$method) {
  
  df$this_base <- as.factor(base_clusterings[[meth]])
  aa <- ggplot(df, aes(x=row, y=col, colour=this_base)) + 
    geom_point(size = .5) +
    theme_void() +
    theme(legend.position = "none") +
    xlab("") + ylab("") +
    scale_colour_manual(values = palette) +
    scale_x_continuous(expand = expansion(0,1)) +
    # scale_y_continuous(expand = expansion(0,1)) +
    ggtitle(meth) + coord_fixed() +
    scale_y_reverse(expand = expansion(0,1)) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm"))
  count <- count+1
  plots[[count]] <- aa
  
  
}


ggsave("8methods-exemplary.pdf",
       plot_grid(plotlist = plots, nrow=2), height = 4.5, width = 9)




```


## Across-clusterings-entropy for selected clusterings

```{r across-clusterings-entropy, fig.width=10, fig.height=5.5}

q <- vector("list", length = length(nclust_range))
count <- 1

nmethod_range <- 3:15

cents <- matrix(0, nrow=length(nmethod_range),
                ncol = length(nclust_range),
                dimnames = list(nmethod_range, nclust_range))

anno_row$meth <- sapply(strsplit(rownames(anno_row), "_"), .subset, 1)

for(nmethod in nmethod_range) {
  for(nclust in nclust_range) {
    
    long_list <- anno_row[rownames(anno_row)!="annotation",] %>% 
      filter(real_n==nclust, clust==2) %>% arrange(entropy)
    
    short_list <- long_list[!duplicated(long_list$meth),] %>% 
      head(nmethod)
      
    # use "smoothest" as reference
    ref_clustering <- rownames(short_list)[1]

    these_clusterings <- base_clusterings %>%
      dplyr::select(rownames(short_list)) %>%
      align_classes(ref_clustering)
    
    lv <- levels(these_clusterings[[ref_clustering]])
    ps <- apply(these_clusterings, 1,
                function(u) table(factor(u,levels = lv))) %>% t
    
    coords$ent <- apply(ps, 1, calc_entropy)
    
    cents[as.character(nmethod), as.character(nclust)] <- mean(coords$ent)
    
    ace_q <- ggplot(coords, aes(row,col,colour=ent)) +
      geom_point(size = 1) +
      scale_colour_gradient(low="gray90", high="deeppink4") +
      theme_void() +
      theme(legend.position = "bottom") +
      scale_x_continuous(expand = expansion(0,1)) +
      scale_y_continuous(expand = expansion(0,1)) +
      coord_fixed() +
      labs(title = paste0("ACE (", 
                          nclust, " clusters, ",
                          nmethod, " methods)"),
           subtitle = paste0(strwrap(paste0(keepers, 
                                            collapse = " "), width=100),
                             collapse="\n")) +
      theme(plot.subtitle=element_text(size=8))
    show(ace_q)
    q[[count]] <- ace_q
    count <- count + 1
    
  }

}

cents


ggsave(filename = paste0(fn_stub, "across-clusterings-entropy.pdf"),
       plot = marrangeGrob(q, nrow=1, ncol=1),
       width = 8, height = 6)

pheatmap(cents, cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         color = colorRampPalette(c("gray90","deeppink4"))(30))

```


## Base clusterings with spatial metrics

```{r base-clusterings-viz, fig.width=10, fig.height=10, eval=TRUE}

bases <- all_mses %>% sort %>% head(nsmoothest)
bcs <- vector("list", length(bases)*length(gt))
count <- 1

for(i in 1:length(bases)) {
  
  nm <- names(bases)[i]
  nclust <- real_n[nm]
  
  palette <- distinctColorPalette(nclust)
  names(palette) <- 1:nclust
  
  df$this_base <- as.factor(base_clusterings[[nm]])

  aa <- ggplot(df, aes(x=row, y=col, colour=this_base)) + 
    geom_point(size = .5) +
    theme_classic() +
    theme(legend.position = "none") +
    xlab("") + ylab("") +
    scale_colour_manual(values = palette) +
    scale_x_continuous(expand = expansion(0,1)) +
    scale_y_continuous(expand = expansion(0,1)) +
    ggtitle(nm) + coord_fixed()
  
  for(j in 1:length(gt)) {
    
    sem <- getSpatialExternalMetrics(true = as.factor(obs[[gt[j]]]),
                                     pred = base_clusterings[[nm]], 
                                     location = df[,c("row","col")],
                                     metrics = "spotAgreement",
                                     level = "element", k = k,
                                     useNegatives = FALSE)
    df$spot_agreement <- sem$spotAgreement

    bb <- ggplot(df, aes(row, col, colour = spot_agreement)) + 
      geom_point(size = .5) + 
      scale_colour_gradient(low="gray90", high="deeppink4") +
      theme(legend.position = "none") +
      scale_x_continuous(expand = expansion(0,1)) +
      scale_y_continuous(expand = expansion(0,1)) +
      theme_classic() +
      theme(legend.position = "none") +
      xlab("") + ylab("") +
      coord_fixed() +
      ggtitle("spotAgreement")
    
    cc <- ggplot(df, aes(row, col, colour = 1-spot_agreement)) + 
      geom_point(size = .5) +
      scale_colour_gradient(low="gray90", high="deeppink4") +
      theme(legend.position = "none") +
      scale_x_continuous(expand = expansion(0,1)) +
      scale_y_continuous(expand = expansion(0,1)) +
      theme_classic() +
      theme(legend.position = "none") +
      xlab("") + ylab("") +
      coord_fixed() +
      ggtitle("1-spotAgreement")
    
    df$ground_truth <- as.factor(obs[[gt[j]]])
    ngt <- length(unique(df$ground_truth))
    set.seed(1234)
    palette <- distinctColorPalette(ngt)
    names(palette) <- levels(df$gt)
    
    dd <- ggplot(df, aes(x=row, y=col, colour=ground_truth)) + 
      geom_point(size = .5) +
      theme_classic() +
      theme(legend.position = "none") +
      xlab("") + ylab("") +
      scale_colour_manual(values = palette) +
      scale_x_continuous(expand = expansion(0,1)) +
      scale_y_continuous(expand = expansion(0,1)) +
      ggtitle(gt[j]) + coord_fixed()
    
    bcs[[count]] <- plot_grid(aa,dd,bb,cc, nrow=2, ncol=2)
    show(bcs[[count]])
    count <- count+1

  }

}

ggsave(filename = paste0(fn_stub, "_04_base-clusterings.pdf"),
       plot = marrangeGrob(bcs, nrow=1, ncol=1),
       width = 9, height = 5)

```


## Assemble artifacts, write to file

```{r assemble-dataframe}

out_df <- cbind(coords, base_clusterings[,names(all_mses)], 
                obs[,gt])

saveRDS(out_df, 
        file.path(datadir, paste0("df_", name, ".rds")))
saveRDS(all_mses, 
        file.path(datadir, paste0("spot-entropies_", name, ".rds")))


```


## sessionInfo()

```{r sessioninfo}
sessionInfo()
```

