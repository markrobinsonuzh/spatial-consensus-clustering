---
title: "Code for Rebuttal Figures"
format: 
    html:
      toc: true
      self-contained: true
      highlight-style: github
      code-line-numbers: true
      code-fold: true
editor: source
editor_options: 
  chunk_output_type: console
#params:
#  datadir: 'test'
#  nmethod_range:
#  ground_truth:
#  nns: 6
#  name: "noname"
#  nclust_range:
#  nsmoothest: 30
#  obs_filter: NULL
---

## Retrieve parameters

```{r display-params}
datadir <- "data/libd-for-figure3"
name <- "fig3"
nclust_range <- c(5,7,9)
nmethod_range <- 5:12


# gt <- c("parcellation_structure","parcellation_substructure")
# k <- 6
# nclust_range <- c(16,20,24)
# nmethod_range <- c(3,4,5,6,7,8,9)
# nsmoothest <- c(30)
# obs_filter <- 'parcellation_division=="TH" | parcellation_structure=="ZI"'

# if datadir ends in `/`, it screws up the parsing of method names,
# so add a check for it
stopifnot(tail(strsplit(datadir,"")[[1]],1)!="/")

```

## Packages / functions

```{r load-packages}
suppressPackageStartupMessages({
  library(SpatialExperiment)
  library(dplyr)
  library(ggplot2)
  library(cowplot)
  library(clue)
  library(khroma)
  library(scran)
  library(limma)
  library(tibble)
  library(readr)
  library(ggrepel)
  library(mclust)
  library(pheatmap)
  library(fastDummies)
  library(randomcoloR)
  library(STexampleData)
  library(reshape2)
  library(poem)
  library(gridExtra)
})
source("utils.R")
```


## Load data (n.b.: not a perfect match to ExperimentHub)

```{r load-data}

spe <- Visium_humanDLPFC()


# QUALITY CONTROL (QC)
# subset to keep only spots over tissue
spe <- spe[, colData(spe)$in_tissue == 1]
# identify mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
# calculate per-spot QC metrics
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
# select QC thresholds
qc_lib_size <- colData(spe)$sum < 600
qc_detected <- colData(spe)$detected < 400
qc_mito <- colData(spe)$subsets_mito_percent > 28
qc_cell_count <- colData(spe)$cell_count > 10
# combined set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito | qc_cell_count
colData(spe)$discard <- discard
# filter low-quality spots
spe <- spe[, !colData(spe)$discard]

# NORMALIZATION
# calculate logcounts using library size factors
spe <- logNormCounts(spe)
spe <- spe[!is_mito, ]

keep <- !is.na(spe$ground_truth)
spe <- spe[,keep]

spe$col <- spatialCoords(spe)[,"pxl_row_in_fullres"]
spe$row <- spatialCoords(spe)[,"pxl_col_in_fullres"]


cd <- colData(spe)

# ggplot(cd %>% as.data.frame,
#        aes(x = row, y = col, colour=ground_truth)) +
#   geom_point() +
#   scale_y_reverse()




base_clusterings <- read_tsv(file.path(datadir, "libd_dlpfc/Br8100_151673",
                                       "combined_methods.tsv"),
                             show_col_types = FALSE)
# base_clusterings <- read_tsv(file.path(datadir, 
#                                        "combined_methods.tsv"),
#                              show_col_types = FALSE)
colnames(base_clusterings)[1] <- "barcode_id"

mean(cd$barcode_id %in% base_clusterings$barcode_id)

mean(base_clusterings$barcode_id %in% cd$barcode_id)

dim(cd)

dim(base_clusterings)

m <- match(cd$barcode_id, base_clusterings$barcode_id)
sum(is.na(m))

base_clusterings <- base_clusterings[m,]

dim(base_clusterings)

cns <- grep("_label$", colnames(base_clusterings), 
            value = TRUE)
ss <- strsplit(cns, "_")
sapply(ss, length) %>% table
keep <- sapply(ss, function(u) u[length(u)-1]) %in% nclust_range
base_clusterings <- base_clusterings[,c("barcode_id",cns[keep])]

dim(base_clusterings)

colnames(base_clusterings) <- gsub("_label","", colnames(base_clusterings))

# 
# base_clusts <- base_clusterings %>% 
#   inner_join(cd %>% as.data.frame %>% 
#                select(barcode_id, row, col, ground_truth))
# 
# 
# # quick scan
# lapply(base_clusts, head, 2)

all(base_clusterings$barcode_id == spe$barcode_id)

# "-" this causes problems later (with LCA)
colnames(base_clusterings) <- gsub("SCAN-IT", "SCANIT", 
                                   colnames(base_clusterings))

rownames(base_clusterings) <- NULL
base_clusterings <- base_clusterings %>%
  as.data.frame %>%
  column_to_rownames("barcode_id")


```


## Smoothness-entropy of base clusterings (not used)

```{r smoothness-entropy, fig.width=8, fig.height=6, eval=TRUE}


# # find number of actual clusters per column
real_n <- apply(base_clusterings, 2,
                function(u) length(unique(u)))
table(real_n)

base_clusterings <- base_clusterings[,real_n %in% nclust_range]


real_n <- apply(base_clusterings, 2,
                function(u) length(unique(u)))
table(real_n)
# 
# 
# # focus on clusterings at single number of clusters, loop through
# p <- vector("list", length = length(nclust_range))
# count <- 1
# 
# all_mses <- NULL
# k <- 6
# 
# for(nclust in nclust_range) {
# 
#   these_clusterings <- base_clusterings %>%
#     dplyr::select(names(which(real_n==nclust)))
# 
#   coords <- colData(spe) %>% as.data.frame %>%
#     dplyr::select(barcode_id, row, col)
# 
#   df <- these_clusterings %>%
#     rownames_to_column("barcode_id") %>%
#     left_join(coords, by = "barcode_id")
# 
#   palette <- distinctColorPalette(nclust)
#   names(palette) <- 1:nclust
# 
#   mse <- apply(these_clusterings, 2,
#                function(u) spot_entropy(coords[,c("row","col")],
#                                         u, k=k))
#   cm <- mse %>% colMeans
#   lv <- cm %>% sort %>% names
#   print(cm)
# 
#   all_mses <- append(all_mses, cm)
# 
#   mse_m <- melt(mse, value.name = "entropy")
#   mse_m$Var2 <- factor(mse_m$Var2, levels=lv)
# 
#   mse_p <- ggplot(mse_m, aes(Var2, entropy)) +
#     geom_violin() +
#     ylab(paste0("pointwise entropy (k=", k, ")")) +
#     xlab("base clustering") +
#     theme_classic() +
#     theme(axis.text.x = element_text(angle = 45,
#                                      vjust = 1, hjust=1)) +
#     geom_label(data = data.frame(Var2=names(cm),
#                                  entropy = cm, label=round(cm,4)),
#                mapping = aes(x=Var2,y=entropy,label=label), size = 2) +
#     scale_y_sqrt() +
#     ggtitle(paste0("Smoothness-entropy (", nclust, " clusters)"))
# 
#   # show(mse_p)
#   p[[count]] <- mse_p
#   count <- count+1
# 
# }
# 
# 
# mse_anno <- spot_entropy(coords[,c("row","col")], spe$ground_truth, k=k) %>% 
#   mean %>% setNames("annotation")
# all_mses <- append(all_mses, mse_anno)
# 
# real_n <- c(real_n, length(unique(cd$ground_truth)))
# names(real_n)[length(real_n)] <- "annotation"
# 
# m <- match(names(real_n), names(all_mses))
# all_mses <- all_mses[m]
# 
# all(names(all_mses)==names(real_n))
# 
# 
# ggsave(filename = paste0("figure-3-smoothness-entropy.pdf"),
#        plot = marrangeGrob(p, nrow=3, ncol=1),
#        width = 10, height = 15)
# 
# # all_mses

```


## Similarity of all clusterings: 

```{r clustering-similarities, fig.height=9, fig.width=10}
# keepers <- names(bases)
# aris_all <- calc_aris(cbind(base_clusterings,
#                             annotation=cd[,"ground_truth"]))
# all(colnames(aris_all) %in% names(all_mses))

aris_all <- calc_aris(base_clusterings)


# anno_row <- data.frame(entropy = all_mses)
# rownames(anno_row) <- names(all_mses)

anno_row <- data.frame(n_clust = real_n)
rownames(anno_row) <- names(real_n)

# spot check
all(names(real_n)==rownames(aris_all))

# anno_row$panelA <- "not-shown"
# anno_row$panelA[rownames(anno_row)=="annotation"] <- "annotation"

ann_colors = list(
    n_clust = c("5" = "#1B9E77", "7" = "orange", "9" = "firebrick")
)


# ph_all <- pheatmap(aris_all, fontsize = 5, 
#                    annotation_row = anno_row,
#                    annotation_colors = ann_colors)

anno_row1 <- anno_row
ss <- strsplit(rownames(anno_row1), "_")
method <- sapply(ss, .subset, 1)
methods <- method  %>% unique #%>% setdiff("annotation")

mat <- matrix(0, nrow = nrow(anno_row1), 
       ncol = length(methods), 
       dimnames = list(rownames(anno_row1), methods))

anno_row1 <- cbind(anno_row1, mat)

for(meth in methods) {
  ann_colors[[meth]] <- c("0" = "grey95", "1" = "black")
  anno_row1[method==meth,meth] <- 1
}

cats_list <- list()
cats_list$`Embedding-Clustering` <- c("BANKSY","stardust","spatialGE",
                                      "meringue","SCANIT")
cats_list$DL <- c("spaGCN","SEDR","SpaceFlow","SOTIP",
                  "GraphST","STAGATE")
cats_list$`Bayesian-HMRF` <- c("BayesSpace","precast","scMEB",
                               "DRSC","SpiceMix","CellCharter",
                               "maple","bass","Giotto")
cats_list$`non-spatial` <- c("scanpy", "seurat")

# scMEB
# Giotto

# > setdiff(unname(unlist(cats_list)), colnames(anno_row1))
# [1] "scMEB"  "Giotto"
# 
# > colnames(anno_row1)
#  [1] "entropy"     "n_clust"     "scanpy"      "SOTIP"       "DRSC"       
#  [6] "seurat"      "CellCharter" "BayesSpace"  "STAGATE"     "stardust"   
# [11] "SpiceMix"    "BANKSY"      "spatialGE"   "maple"       "spaGCN"     
# [16] "SEDR"        "meringue"    "precast"     "SC"          "bass"       
# [21] "SpaceFlow"   "SCANIT"      "GraphST"   

cats <- matrix(0, nrow = nrow(anno_row1),
               ncol = length(cats_list),
               dimnames = list(rownames(anno_row1), names(cats_list)))
anno_row1 <- cbind(anno_row1, cats)

for(cat in 1:length(cats_list)) {
  ann_colors[[names(cats_list)[cat]]] <- c("0" = "grey85", "1" = "darkorange")
  anno_row1[method %in% cats_list[[cat]],names(cats_list)[cat]] <- 1
}

anno_row1$n_clust <- NULL

ph_all <- pheatmap(aris_all, fontsize = 5, 
                   annotation_row = anno_row1,
                   annotation_colors = ann_colors,
                   annotation_legend = FALSE)

save_pheatmap_pdf(ph_all, "rebuttal-libd-methodclass.pdf", width=13, height=9)

```


## sessionInfo()

```{r sessioninfo}
sessionInfo()
```

